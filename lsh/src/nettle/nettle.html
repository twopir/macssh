<html lang="en"><head>
<title>The Nettle low-level cryptographic library.</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="The Nettle low-level cryptographic library.">
<meta name=generator content="makeinfo 4.0">
<link href="http://texinfo.org/" rel=generator-home>
</head><body>

<p><hr>
Node:<a name="Top">Top</a>,
Next:<a rel=next href="#Introduction">Introduction</a>,
Previous:<a rel=previous href="#(dir)">(dir)</a>,
Up:<a rel=up href="#(dir)">(dir)</a>
<br>

<h1></h1>

<p>This document describes the nettle low-level cryptographic library. You
can use the library directly from your C-programs, or (recommended)
write or use an object-oriented wrapper for your favourite language or
application.

<p>This manual coresponds to version 0.2 of the library.

<ul>
<li><a href="#Introduction">Introduction</a>: 
<li><a href="#Copyright">Copyright</a>: 
<li><a href="#Conventions">Conventions</a>: 
<li><a href="#Example">Example</a>: 
<li><a href="#Reference">Reference</a>: 
<li><a href="#Installation">Installation</a>: 
<li><a href="#Index">Index</a>: 
</ul>

<p><hr>
Node:<a name="Introduction">Introduction</a>,
Next:<a rel=next href="#Copyright">Copyright</a>,
Previous:<a rel=previous href="#Top">Top</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Introduction</h1>

<p>Nettle is a cryptographic library that is designed to fit easily in more
or less any context: In crypto toolkits for object-oriented languages
(C++, Python, Pike, ...), in applications like LSH or GNUPG, or even in
kernel space. In most contexts, you need more than the basic
cryptographic algorithms, you also need some way to keep track of available
algorithms, their properties and variants. You often have some algorithm
selection process, often dictated by a protocol you want to implement.

<p>And as the requirements of applications differ on subtle and not so
subtle ways, an API that fits one application well can be a pain to use
in a different context. And that is why there are so many different
cryptographic libraries around.

<p>Nettle tries to avoid this problem by doing one thing, the low-level
crypto stuff, and providing a <em>simple</em> but general interface to it. 
In particular, Nettle doesn't do algorithm selection. It doesn't do
memory allocation. It doesn't do any I/O.

<p>The idea is that one can build several application and context specific
interfaces on top of Nettle, and share the code, testcases, banchmarks,
documentation, etc. For this first version, the only application using
Nettle is LSH, and it uses an object-oriented abstraction on top of the
library.

<p><hr>
Node:<a name="Copyright">Copyright</a>,
Next:<a rel=next href="#Conventions">Conventions</a>,
Previous:<a rel=previous href="#Introduction">Introduction</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Copyright</h1>

<p>Nettle is distributed under the GNU General Public License (see the file
COPYING for details). However, many of the individual files are dual
licensed under less restrictive licenses like the GNU Lesser General
Public License, or public domain. Consult the headers in each file for
details.

<p>It is conceivable that future versions will use the LGPL rather than the
GPL, mail me if you have questions or suggestions.

<p>A list of the supported algorithms, their origins and licenses:

<dl>
<dt><em>AES</em>
<dd>The implementation of the AES cipher (also known as rijndael) is written
by Rafael Sevilla. Released under the LGPL.

<br><dt><em>ARCFOUR</em>
<dd>The implementation of the ARCFOUR (also known as RC4) cipher is written
by Niels Möller. Released under the LGPL.

<br><dt><em>BLOWFISH</em>
<dd>The implementation of the BLOWFISH cipher is written by Werner Koch,
copyright owned by the Free Software Foundation. Also hacked by Ray
Dassen and Niels Möller. Released under the GPL.

<br><dt><em>CAST128</em>
<dd>The implementation of the CAST128 cipher is written by Steve Reid. 
Released into the public domain.

<br><dt><em>DES</em>
<dd>The implementation of the DES cipher is written by Dana L. How, and
released under the LGPL.

<br><dt><em>MD5</em>
<dd>The implementation of the MD5 message digest is written by Colin Plumb. 
It has been hacked some more by Andrew Kuchling and Niels Möller. 
Released into the public domain.

<br><dt><em>SERPENT</em>
<dd>The implementation of the SERPENT cipher is written by Ross Anderson,
Eli Biham, and Lars Knudsen, adapted to LSH by Rafael Sevilla, and to
Nettle by Niels Möller.

<br><dt><em>SHA1</em>
<dd>The implementation of the SHA1 message digest is written by Peter
Gutmann, and hacked some more by Andrew Kuchling and Niels Möller. 
Released into the public domain.

<br><dt><em>TWOFISH</em>
<dd>The implementation of the TWOFISH cipher is written by Ruud de Rooij. 
Released under the LGPL. 
</dl>

<p><hr>
Node:<a name="Conventions">Conventions</a>,
Next:<a rel=next href="#Example">Example</a>,
Previous:<a rel=previous href="#Copyright">Copyright</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Conventions</h1>

<p>For each supported algorithm, there is an include file that defines a
<em>context struct</em>, a few constants, and declares functions for
operating on the state. The context struct encapsulates all information
needed by the algorithm, and it can be copied or moved in memory with no
unexpected effects.

<p>The functions for similar algorithms are similar, but there are some
differences, for instance reflecting if the key setup or encryption
function differ for encryption and encryption, and whether or not key
setup can fail. There are also differences that doesn't show in function
prototypes, but which the application must nevertheless be aware of. 
There is no difference between stream ciphers and block ciphers,
although they should be used quite differently by the application.

<p>If your application uses more than one algorithm, you should probably
create an interface that is tailor-made for your needs, and then write a
few lines of glue code on top of Nettle.

<p>By convention, for an algorithm named <code>foo</code>, the struct tag for the
context struct is <code>foo_ctx</code>, constants and functions uses prefixes
like <code>FOO_BLOCK_SIZE</code> (a constant) and <code>foo_set_key</code> (a
function).

<p>In all functions, strings are represented with an explicit length, of
type <code>unsigned</code>, and a pointer of type <code>uint8_t *</code> or a
<code>const uint8_t *</code>. For functions that transform one string to
another, the argument order is length, destination pointer and source
pointer. Source and destination areas are of the same length. Source and
destination may be the same, so that you can process strings in place,
but they must not overlap in any other way.

<p><hr>
Node:<a name="Example">Example</a>,
Next:<a rel=next href="#Reference">Reference</a>,
Previous:<a rel=previous href="#Conventions">Conventions</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Example</h1>

<p>A simple example program that reads a file from standard in and writes
its SHA1 checksum on stdout should give the flavour of Nettle.

<pre>/* FIXME: This code is untested. */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;nettle/sha1.h&gt;

#define BUF_SIZE 1000

static void
display_hex(unsigned length, uint8_t *data)
{
  static const char digits[16] = "0123456789abcdef";
  unsigned i;

  for (i = 0; i&lt;length; i++)
  {
    uint8_t byte = data[i];
    printf("%c%c ", digits[(byte / 16) &amp; 0xf], digits[byte &amp; 0xf]);
  }
}

int
main(int argc, char **argv)
{
  struct sha1_ctx ctx;
  uint8_t buffer[BUF_SIZE];
  uint8_t digest[SHA1_DIGEST_SIZE];

  sha1_init(&amp;ctx);
  for (;;)
  {
    int done = fread(buffer, 1, sizeof(buffer), stdin);
    if (done &lt;= 0)
      break;
    sha1_update(&amp;ctx, done, buf);
  }
  if (ferror(stdin))
    return EXIT_FAILURE;

  sha1_finish(&amp;ctx);
  sha1_digest(&amp;ctx, SHA1_DIGEST_SIZE, digest);

  display_hex(SHA1_DIGEST_SIZE, digest);
  return EXIT_SUCCESS;
}
</pre>

<p><hr>
Node:<a name="Reference">Reference</a>,
Next:<a rel=next href="#Installation">Installation</a>,
Previous:<a rel=previous href="#Example">Example</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Reference</h1>

<p>This chapter describes all the Nettle functions, grouped by family.

<ul>
<li><a href="#Hash%20functions">Hash functions</a>: 
<li><a href="#Cipher%20functions">Cipher functions</a>: 
<li><a href="#Miscellaneous%20functions">Miscellaneous functions</a>: 
</ul>

<p><hr>
Node:<a name="Hash%20functions">Hash functions</a>,
Next:<a rel=next href="#Cipher%20functions">Cipher functions</a>,
Previous:<a rel=previous href="#Reference">Reference</a>,
Up:<a rel=up href="#Reference">Reference</a>
<br>

<h2>Hash functions</h2>

<p>A cryptographic <dfn>hash function</dfn> is a function that takes variable
size strings, and maps them to strings of fixed, short, length. There
are naturally lots of collisions, as there are more possible 1MB files
than 20 byte strings. But the function is constructed such that is hard
to find the collisions. More precisely, a cryptographic hash function
<code>H</code> should have the following properties:

<dl>

<br><dt><em>One-way</em>
<dd>Given a hash value <code>H(x)</code> it is hard to find a string <code>x</code>
that hashes to that value.

<br><dt><em>Collision-resistant</em>
<dd>It is hard to find two different strings, <code>x</code> and <code>y</code>, such
that <code>H(x)</code> = <code>H(y)</code>.

</dl>

<p>Hash functions are useful as building blocks for digital signatures,
message authentication codes, pseudo random generators, associating
unique id:s to documents, and many other things.

<h3><small>MD5</small></h3>

<p>MD5 is a message digest function constructed by Ronald Rivest, and
described in <cite>RFC 1321</cite>. It outputs message digests of 128 bits, or
16 octets. Nettle defines MD5 in <code>&lt;nettle/md5.h&gt;</code>.

<p>
<table width="100%">
<tr>
<td align="left"><b>struct md5_ctx</b><i>
</i></td>
<td align="right">Context struct</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left"><b>MD5_DIGEST_SIZE</b><i>
</i></td>
<td align="right">Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The size of an MD5 digest, i.e. 16. 
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left"><b>MD5_DATA_SIZE</b><i>
</i></td>
<td align="right">Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The internal block size of MD5. Useful for some special constructions,
in particular HMAC-MD5. 
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left">void <b>md5_init</b><i> (struct md5_ctx *<var>ctx</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Initialize the MD5 state. 
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left">void <b>md5_update</b><i> (struct md5_ctx *<var>ctx</var>, unsigned <var>length</var>, const uint8_t *<var>data</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Hash some more data. 
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left">void <b>md5_final</b><i> (struct md5_ctx *<var>ctx</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Performs final processing that is needed after all input data has been
processed with <code>md5_update</code>. 
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left">void <b>md5_digest</b><i> (struct md5_ctx *<var>ctx</var>, unsigned <var>length</var>, uint8_t *<var>digest</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Extracts the digest, writing it to <var>digest</var>. <var>length</var> may be smaller than
<code>MD5_DIGEST_SIZE</code>, in which case only the first <var>length</var> octets
of the digest are written.

<p>This functions doesn't change the state in any way. 
</TD></TR>
</TABLE>

<p>The normal way to use MD5 is to call the functions in order: First
<code>md5_init</code>, then <code>md5_update</code> zero or more times, then
<code>md5_final</code>, and at last <code>md5_digest</code> zero or more times.

<p>To start over, you can call <code>md5_init</code> at any time.

<h3><small>SHA1</small></h3>

<p>SHA1 is a hash function specified by <dfn>NIST</dfn> (The U.S. National Institute
for Standards and Technology. It outputs hash values of 160 bits, or 20
octets. Nettle defines SHA1 in <code>&lt;nettle/sha1.h&gt;</code>.

<p>The functions are analogous to the MD5 ones.

<p>
<table width="100%">
<tr>
<td align="left"><b>struct sha1_ctx</b><i>
</i></td>
<td align="right">Context struct</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left"><b>SHA1_DIGEST_SIZE</b><i>
</i></td>
<td align="right">Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The size of an SHA1 digest, i.e. 20. 
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left"><b>SHA1_DATA_SIZE</b><i>
</i></td>
<td align="right">Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The internal block size of SHA1. Useful for some special constructions,
in particular HMAC-SHA1. 
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left">void <b>sha1_init</b><i> (struct sha1_ctx *<var>ctx</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Initialize the SHA1 state. 
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left">void <b>sha1_update</b><i> (struct sha1_ctx *<var>ctx</var>, unsigned <var>length</var>, const uint8_t *<var>data</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Hash some more data. 
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left">void <b>sha1_final</b><i> (struct sha1_ctx *<var>ctx</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Performs final processing that is needed after all input data has been
processed with <code>sha1_update</code>. 
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left">void <b>sha1_digest</b><i> (struct sha1_ctx *<var>ctx</var>, unsigned <var>length</var>, uint8_t *<var>digest</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Extracts the digest, writing it to <var>digest</var>. <var>length</var> may be smaller than
<code>SHA1_DIGEST_SIZE</code>, in which case only the first <var>length</var> octets
of the digest are written.

<p>This functions doesn't change the state in any way. 
</TD></TR>
</TABLE>

<p><hr>
Node:<a name="Cipher%20functions">Cipher functions</a>,
Next:<a rel=next href="#Miscellaneous%20functions">Miscellaneous functions</a>,
Previous:<a rel=previous href="#Hash%20functions">Hash functions</a>,
Up:<a rel=up href="#Reference">Reference</a>
<br>

<h2>Cipher functions</h2>

<p>A <dfn>cipher</dfn> is a function that takes a message or <dfn>plaintext</dfn>
and a secret <dfn>key</dfn> and transforms it to a <dfn>ciphertext</dfn>. Given
only the ciphertext, but not the key, it should be hard to find the
cleartext. Given matching pairs of plaintext and ciphertext, it should
be hard to find the key.

<p>To do this, you first initialize the cipher context for encryption or
decryption with a particular key, then use it to process plaintext och
ciphertext messages. The initialization is also called <dfn>key setup</dfn>. 
With Nettle, it is recommended to use each context struct for only one
direction, even if some of the ciphers use a single key setup function
that can be used for both encryption and decryption.

<p>There are two main classes of ciphers: Block ciphers and stream ciphers.

<p>A block cipher can process data only in fixed size chunks, called
<dfn>blocks</dfn>. Typical block sizes are 8 or 16 octets. To encrypt
arbitrary messages, you usually have to pad it to an integral number of
blocks, split it into blocks, and then process each block. The simplest
way is to process one block at a time, independent of each other. That
mode of operation is called <dfn>ECB</dfn>, Electronic Code Book mode. 
However, using ECB is usually a bad idea. For a start, plaintext blocks
that are equal are transformed to ciphertext blocks that are equal; that
leaks information about the plaintext. Usually you should apply the
cipher is some feedback mode, <dfn>CBC</dfn> (Cipher Block Chaining) being one
of the most popular.

<p>A stream cipher can be used for messages of arbitrary length; a typical
stream cipher is a keyed pseudorandom generator. To encrypt a plaintext
message of <var>n</var> octets, you key the generator, generate <var>n</var>
octets of pseudorandom data, and XOR it with the plaintext. To decrypt,
regenerate the same stream using the key, XOR it to the ciphertext, and
the plaintext is recovered.

<p><strong>Caution:</strong> The first rule for this kind of cipher is the
same as for a One Time Pad: <em>never</em> ever use the same key twice.

<p>A common misconception is that encryption, by itself, implies
authentication. Say that you and a friend share a secret key, and you
receive an encrypted message, apply the key, and get a cleartext message
that makes sense to you. Can you then be sure that it really was your
friend that wrote the message you're reading? The anser is no. For
example, if you were using a block cipher in ECB mode, an attacker may
pick up the message on its way, and reorder, delete or repeat some of
the blocks. Even if the attacker can't decrypt the message, he can
change it so that you are not reading the same message as your friend
wrote. If you are using a block cipher in CBC mode rather than ECB, or
are using a stream cipher, the possibilities for this sort of attack are
different, but the attacker can still make predictable changes to the
message.

<p>It is recommended to <em>always</em> use an authentication mechanism in
addition to encrypting the messages. Popular choices are Message
Authetication Codes like HMAC-SHA1, or digital signatures.

<p>Some ciphers have so called "weak keys", keys that results in
undesirable structure after the key setup processing, and should be
avoided. In Nettle, the presence of weak keys for a cipher mean that the
key setup function can fail, so you have to check its return value. In
addition, the context struct has a field <code>status</code>, that is set to a
non-zero value if key setup fails. When possible, avoid algorithm that
have weak keys. There are several good ciphers that don't have any weak
keys.

<h3>AES</h3>

<p>AES is a quite new block cipher, specified by NIST as a replacement for
the older DES standard. It is the result of a competition between cipher
designers, and the winning design, constructed by Joan Daemen and
Vincent Rijnmen. Before it won the competition, it was known under the
name RIJNDAEL.

<p>Like all the AES candidates, the winning design uses a block size of 128
bits, or 16 octets, and variable keysize, 128, 192 and 256 bits (16, 24
and 32 octets) being the allowed key sizes. It does not have any weak
keys. Nettle defines AES in <code>&lt;nettle/aes.h&gt;</code>.

<p>
<table width="100%">
<tr>
<td align="left"><b>struct aes_ctx</b><i>
</i></td>
<td align="right">Context struct</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left"><b>AES_BLOCK_SIZE</b><i>
</i></td>
<td align="right">Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The AES blocksize, 16
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left"><b>AES_MIN_KEY_SIZE</b><i>
</i></td>
<td align="right">Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left"><b>AES_MAX_KEY_SIZE</b><i>
</i></td>
<td align="right">Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left"><b>AES_KEY_SIZE</b><i>
</i></td>
<td align="right">Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Default AES key size, 32
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left">void <b>aes_set_key</b><i> (struct aes_ctx *<var>ctx</var>, unsigned <var>length</var>, const uint8_t *<var>key</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Initialize the cipher. The same function is used for both encryption and
decryption. 
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left">void <b>aes_encrypt</b><i> (struct aes_ctx *<var>ctx</var>, unsigned <var>length</var>, const uint8_t *<var>dst</var>, uint8_t *<var>src</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Encryption function. <var>length</var> must be an integral multiple of the
block size. If it is more than one block, the data is processed in ECB
mode. <code>src</code> and <code>dst</code> may be equal, but they must not overlap
in any other way. 
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left">void <b>aes_decrypt</b><i> (struct aes_ctx *<var>ctx</var>, unsigned <var>length</var>, const uint8_t *<var>dst</var>, uint8_t *<var>src</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Analogous to <code>aes_encrypt</code>
</TD></TR>
</TABLE>

<h3>ARCFOUR</h3>

<p>ARCFOUR is a stream cipher, also known under the trade marked name RC4,
and it is one of the fastest ciphers around. A problem is that the key
setup of ARCFOUR is quite weak, you should never use keys with
structure, keys that are ordinary passwords, or sequences of keys like
"secret:1", "secret:2", <small>...</small>.. If you have keys that don't look
like random bit strings, and you want to use ARCFOUR, always hash the
key before feeding it to ARCFOUR. For example

<pre>/* A more robust key setup function for ARCFOUR */
void
my_arcfour_set_key(struct arcfour_ctx *ctx,
                   unsigned length, const uint8_t *key)
{
  struct sha1_ctx hash;
  uint8_t digest[SHA1_DIGEST_SIZE];

  sha1_init(&amp;hash);
  sha1_update(&amp;hash, length, key);
  sha1_final(&amp;hash);
  sha1_digest(&amp;hash, SHA1_DIGEST_SIZE, digest);

  arcfour_set_key(ctx, SHA1_DIGEST_SIZE, digest);
}
</pre>

<p>Nettle defines ARCFOUR in <code>&lt;nettle/arcfour.h&gt;</code>.

<p>
<table width="100%">
<tr>
<td align="left"><b>struct arcfour_ctx</b><i>
</i></td>
<td align="right">Context struct</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left"><b>ARCFOUR_BLOCK_SIZE</b><i>
</i></td>
<td align="right">Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The ARCFOUR blocksize, 16
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left"><b>ARCFOUR_MIN_KEY_SIZE</b><i>
</i></td>
<td align="right">Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Minimum key size, 1
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left"><b>ARCFOUR_MAX_KEY_SIZE</b><i>
</i></td>
<td align="right">Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Maximum key size, 256
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left"><b>ARCFOUR_KEY_SIZE</b><i>
</i></td>
<td align="right">Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Default ARCFOUR key size, 16
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left">void <b>arcfour_set_key</b><i> (struct arcfour_ctx *<var>ctx</var>, unsigned <var>length</var>, const uint8_t *<var>key</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Initialize the cipher. The same function is used for both encryption and
decryption. 
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left">void <b>arcfour_crypt</b><i> (struct arcfour_ctx *<var>ctx</var>, unsigned <var>length</var>, const uint8_t *<var>key</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Encrypt some data. The same function is used for both encryption and
decryption. Unlike the block ciphers, this function modifies the
context, so you can split the data into arbitrary chunks and encrypt
them one after another. The result is the same as if you had called
<code>arcfour_crypt</code> only once with all the data. 
</TD></TR>
</TABLE>

<h3>CAST128</h3>

<p>CAST-128 is a block cipher, specified in <cite>RFC 2144</cite>. It uses a 64
bit (8 octets) block size, and a variable key size of up to 128 bits. 
Nettle defines cast128 in <code>&lt;nettle/cast128.h&gt;</code>.

<p>
<table width="100%">
<tr>
<td align="left"><b>struct cast128_ctx</b><i>
</i></td>
<td align="right">Context struct</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left"><b>CAST128_BLOCK_SIZE</b><i>
</i></td>
<td align="right">Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The CAST128 blocksize, 8
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left"><b>CAST128_MIN_KEY_SIZE</b><i>
</i></td>
<td align="right">Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Minumim CAST128 key size, 5
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left"><b>CAST128_MAX_KEY_SIZE</b><i>
</i></td>
<td align="right">Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Maximum CAST128 key size, 16
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left"><b>CAST128_KEY_SIZE</b><i>
</i></td>
<td align="right">Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Default CAST128 key size, 16
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left">void <b>cast128_set_key</b><i> (struct cast128_ctx *<var>ctx</var>, unsigned <var>length</var>, const uint8_t *<var>key</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Initialize the cipher. The same function is used for both encryption and
decryption. 
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left">void <b>cast128_encrypt</b><i> (struct cast128_ctx *<var>ctx</var>, unsigned <var>length</var>, const uint8_t *<var>dst</var>, uint8_t *<var>src</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Encryption function. <var>length</var> must be an integral multiple of the
block size. If it is more than one block, the data is processed in ECB
mode. <code>src</code> and <code>dst</code> may be equal, but they must not overlap
in any other way. 
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left">void <b>cast128_decrypt</b><i> (struct cast128_ctx *<var>ctx</var>, unsigned <var>length</var>, const uint8_t *<var>dst</var>, uint8_t *<var>src</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Analogous to <code>cast128_encrypt</code>
</TD></TR>
</TABLE>

<h3>BLOWFISH</h3>

<p>BLOWFISH is a block cipher designed by Bruce Schneier. It uses a block
size of 64 bits (8 octets), and a variable key size, up to 448 bits. It
has some weak keys. Nettle defines BLOWFISH in <code>&lt;nettle/blowfish.h&gt;</code>.

<p>
<table width="100%">
<tr>
<td align="left"><b>struct blowfish_ctx</b><i>
</i></td>
<td align="right">Context struct</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left"><b>BLOWFISH_BLOCK_SIZE</b><i>
</i></td>
<td align="right">Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The BLOWFISH blocksize, 8
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left"><b>BLOWFISH_MIN_KEY_SIZE</b><i>
</i></td>
<td align="right">Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Minimum BLOWFISH key size, 8
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left"><b>BLOWFISH_MAX_KEY_SIZE</b><i>
</i></td>
<td align="right">Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Maximum BLOWFISH key size, 56
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left"><b>BLOWFISH_KEY_SIZE</b><i>
</i></td>
<td align="right">Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Default BLOWFISH key size, 16
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left">int <b>blowfish_set_key</b><i> (struct blowfish_ctx *<var>ctx</var>, unsigned <var>length</var>, const uint8_t *<var>key</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Initialize the cipher. The same function is used for both encryption and
decryption. Returns 1 on success, and 0 if the key was weak. Calling
<code>blowfish_encrypt</code> or <code>blowfish_decrypt</code> with a weak key will
crash with an assert violation. 
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left">void <b>blowfish_encrypt</b><i> (struct blowfish_ctx *<var>ctx</var>, unsigned <var>length</var>, const uint8_t *<var>dst</var>, uint8_t *<var>src</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Encryption function. <var>length</var> must be an integral multiple of the
block size. If it is more than one block, the data is processed in ECB
mode. <code>src</code> and <code>dst</code> may be equal, but they must not overlap
in any other way. 
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left">void <b>blowfish_decrypt</b><i> (struct blowfish_ctx *<var>ctx</var>, unsigned <var>length</var>, const uint8_t *<var>dst</var>, uint8_t *<var>src</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Analogous to <code>blowfish_encrypt</code>
</TD></TR>
</TABLE>

<h3>DES</h3>

<p>DES is the old Data Encryption Standard, specified by NIST. It uses a
block size of 64 bits (8 octets), and a key size of 56 bits. However,
the key bits are distributed over 8 octets, where the least significant
bit of each octet is used for parity. A common way to use DES is to
generate 8 random octets in some way, then set the least significant bit
of each octet to get odd parity, and initialize DES with the resulting
key.

<p>The key size of DES is so small that keys can be found by brute force,
using specialized hardware or lots of ordinary work stations in
parallell. One shouldn't be using plain DES at all today, if one uses
DES at all one should be using "triple DES", three DES ciphers piped
together, with three (or sometimes just two) independent keys.

<p>DES also has some weak keys. Nettle defines DES in <code>&lt;nettle/des.h&gt;</code>.

<p>
<table width="100%">
<tr>
<td align="left"><b>struct des_ctx</b><i>
</i></td>
<td align="right">Context struct</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left"><b>DES_BLOCK_SIZE</b><i>
</i></td>
<td align="right">Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The DES blocksize, 8
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left"><b>DES_KEY_SIZE</b><i>
</i></td>
<td align="right">Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
DES key size, 8
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left">int <b>des_set_key</b><i> (struct des_ctx *<var>ctx</var>, unsigned <var>length</var>, const uint8_t *<var>key</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Initialize the cipher. The same function is used for both encryption and
decryption. Returns 1 on success, and 0 if the key was weak or had bad
parity. Calling <code>des_encrypt</code> or <code>des_decrypt</code> with a bad key
will crash with an assert violation. 
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left">void <b>des_encrypt</b><i> (struct des_ctx *<var>ctx</var>, unsigned <var>length</var>, const uint8_t *<var>dst</var>, uint8_t *<var>src</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Encryption function. <var>length</var> must be an integral multiple of the
block size. If it is more than one block, the data is processed in ECB
mode. <code>src</code> and <code>dst</code> may be equal, but they must not overlap
in any other way. 
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left">void <b>des_decrypt</b><i> (struct des_ctx *<var>ctx</var>, unsigned <var>length</var>, const uint8_t *<var>dst</var>, uint8_t *<var>src</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Analogous to <code>des_encrypt</code>
</TD></TR>
</TABLE>

<h3>SERPENT</h3>

<p>SERPENT is one of the AES finalists, designed by Ross Anderson, Eli
Biham and Lars Knudsen. Thus, the interface and properties are similar
to AES'. One pecularity is that it is quite pointless to use it with
anything but the maximum key size, smaller keys are just padded to
larger ones. Nettle defines SERPENT in <code>&lt;nettle/serpent.h&gt;</code>.

<p>
<table width="100%">
<tr>
<td align="left"><b>struct serpent_ctx</b><i>
</i></td>
<td align="right">Context struct</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left"><b>SERPENT_BLOCK_SIZE</b><i>
</i></td>
<td align="right">Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The SERPENT blocksize, 16
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left"><b>SERPENT_MIN_KEY_SIZE</b><i>
</i></td>
<td align="right">Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Minumim SERPENT key size, 16
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left"><b>SERPENT_MAX_KEY_SIZE</b><i>
</i></td>
<td align="right">Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Maximum SERPENT key size, 32
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left"><b>SERPENT_KEY_SIZE</b><i>
</i></td>
<td align="right">Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Default SERPENT key size, 32
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left">void <b>serpent_set_key</b><i> (struct serpent_ctx *<var>ctx</var>, unsigned <var>length</var>, const uint8_t *<var>key</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Initialize the cipher. The same function is used for both encryption and
decryption. 
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left">void <b>serpent_encrypt</b><i> (struct serpent_ctx *<var>ctx</var>, unsigned <var>length</var>, const uint8_t *<var>dst</var>, uint8_t *<var>src</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Encryption function. <var>length</var> must be an integral multiple of the
block size. If it is more than one block, the data is processed in ECB
mode. <code>src</code> and <code>dst</code> may be equal, but they must not overlap
in any other way. 
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left">void <b>serpent_decrypt</b><i> (struct serpent_ctx *<var>ctx</var>, unsigned <var>length</var>, const uint8_t *<var>dst</var>, uint8_t *<var>src</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Analogous to <code>serpent_encrypt</code>
</TD></TR>
</TABLE>

<h3>TWOFISH</h3>

<p>Another AES finalist, this one designed by Bruce Schneier and others. 
Nettle defines it in <code>&lt;nettle/twofish.h&gt;</code>.

<p>
<table width="100%">
<tr>
<td align="left"><b>struct twofish_ctx</b><i>
</i></td>
<td align="right">Context struct</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left"><b>TWOFISH_BLOCK_SIZE</b><i>
</i></td>
<td align="right">Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The TWOFISH blocksize, 16
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left"><b>TWOFISH_MIN_KEY_SIZE</b><i>
</i></td>
<td align="right">Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Minumim TWOFISH key size, 16
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left"><b>TWOFISH_MAX_KEY_SIZE</b><i>
</i></td>
<td align="right">Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Maximum TWOFISH key size, 32
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left"><b>TWOFISH_KEY_SIZE</b><i>
</i></td>
<td align="right">Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Default TWOFISH key size, 32
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left">void <b>twofish_set_key</b><i> (struct twofish_ctx *<var>ctx</var>, unsigned <var>length</var>, const uint8_t *<var>key</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Initialize the cipher. The same function is used for both encryption and
decryption. 
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left">void <b>twofish_encrypt</b><i> (struct twofish_ctx *<var>ctx</var>, unsigned <var>length</var>, const uint8_t *<var>dst</var>, uint8_t *<var>src</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Encryption function. <var>length</var> must be an integral multiple of the
block size. If it is more than one block, the data is processed in ECB
mode. <code>src</code> and <code>dst</code> may be equal, but they must not overlap
in any other way. 
</TD></TR>
</TABLE>

<p>
<table width="100%">
<tr>
<td align="left">void <b>twofish_decrypt</b><i> (struct twofish_ctx *<var>ctx</var>, unsigned <var>length</var>, const uint8_t *<var>dst</var>, uint8_t *<var>src</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Analogous to <code>twofish_encrypt</code>
</TD></TR>
</TABLE>

<p><hr>
Node:<a name="Miscellaneous%20functions">Miscellaneous functions</a>,
Previous:<a rel=previous href="#Cipher%20functions">Cipher functions</a>,
Up:<a rel=up href="#Reference">Reference</a>
<br>

<h2>Miscellaneous functions</h2>

<p>
<table width="100%">
<tr>
<td align="left">uint8_t * <b>memxor</b><i> (uint8_t *<var>dst</var>, const uint8_t *<var>src</var>, size_t <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
XOR:s the source area on top of the destination area. The interface
doesn't follow the Nettle conventions, because it is intended to be
similar to the ANSI-C <code>memcpy</code> function. 
</TD></TR>
</TABLE>

<p><hr>
Node:<a name="Installation">Installation</a>,
Next:<a rel=next href="#Index">Index</a>,
Previous:<a rel=previous href="#Reference">Reference</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Installation</h1>

<p>Nettle uses <code>autoconf</code> and <code>automake</code>. To build it,
unpack the source and run

<pre>./configure
make
make check
make install
</pre>

<p>to install in the default location, <code>/usr/local</code>. The library is
installed in <code>/use/local/lib/libnettle.a</code> and the include files are
installed in <code>/use/local/include/nettle/</code>.

<p>Only static libraries are installed.

<p><hr>
Node:<a name="Index">Index</a>,
Previous:<a rel=previous href="#Installation">Installation</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Function and Concept Index</h1>

<ul compact>
<li><code>aes_decrypt</code>: <a href="#Cipher%20functions">Cipher functions</a>
<li><code>aes_encrypt</code>: <a href="#Cipher%20functions">Cipher functions</a>
<li><code>aes_set_key</code>: <a href="#Cipher%20functions">Cipher functions</a>
<li><code>arcfour_crypt</code>: <a href="#Cipher%20functions">Cipher functions</a>
<li><code>arcfour_set_key</code>: <a href="#Cipher%20functions">Cipher functions</a>
<li><code>blowfish_decrypt</code>: <a href="#Cipher%20functions">Cipher functions</a>
<li><code>blowfish_encrypt</code>: <a href="#Cipher%20functions">Cipher functions</a>
<li><code>blowfish_set_key</code>: <a href="#Cipher%20functions">Cipher functions</a>
<li><code>cast128_decrypt</code>: <a href="#Cipher%20functions">Cipher functions</a>
<li><code>cast128_encrypt</code>: <a href="#Cipher%20functions">Cipher functions</a>
<li><code>cast128_set_key</code>: <a href="#Cipher%20functions">Cipher functions</a>
<li><code>des_decrypt</code>: <a href="#Cipher%20functions">Cipher functions</a>
<li><code>des_encrypt</code>: <a href="#Cipher%20functions">Cipher functions</a>
<li><code>des_set_key</code>: <a href="#Cipher%20functions">Cipher functions</a>
<li><code>md5_digest</code>: <a href="#Hash%20functions">Hash functions</a>
<li><code>md5_final</code>: <a href="#Hash%20functions">Hash functions</a>
<li><code>md5_init</code>: <a href="#Hash%20functions">Hash functions</a>
<li><code>md5_update</code>: <a href="#Hash%20functions">Hash functions</a>
<li><code>memxor</code>: <a href="#Miscellaneous%20functions">Miscellaneous functions</a>
<li><code>serpent_decrypt</code>: <a href="#Cipher%20functions">Cipher functions</a>
<li><code>serpent_encrypt</code>: <a href="#Cipher%20functions">Cipher functions</a>
<li><code>serpent_set_key</code>: <a href="#Cipher%20functions">Cipher functions</a>
<li><code>sha1_digest</code>: <a href="#Hash%20functions">Hash functions</a>
<li><code>sha1_final</code>: <a href="#Hash%20functions">Hash functions</a>
<li><code>sha1_init</code>: <a href="#Hash%20functions">Hash functions</a>
<li><code>sha1_update</code>: <a href="#Hash%20functions">Hash functions</a>
<li><code>twofish_decrypt</code>: <a href="#Cipher%20functions">Cipher functions</a>
<li><code>twofish_encrypt</code>: <a href="#Cipher%20functions">Cipher functions</a>
<li><code>twofish_set_key</code>: <a href="#Cipher%20functions">Cipher functions</a>
</ul>


</body></html>

